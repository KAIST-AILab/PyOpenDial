import logging

from multipledispatch import dispatch

from bn.distribs.distribution_builder import CategoricalTableBuilder as CategoricalTableBuilder
from bn.distribs.marginal_distribution import MarginalDistribution
from bn.distribs.prob_distribution import ProbDistribution
from bn.distribs.utility_function import UtilityFunction
from bn.values.value import Value
from datastructs.assignment import Assignment
from datastructs.value_range import ValueRange
from domains.rules.rule import Rule, RuleType


class AnchoredRule(ProbDistribution, UtilityFunction):
    """
    Representation of a probabilistic rule anchored in a particular dialogue state.
    """

    # logger
    log = logging.getLogger('PyOpenDial')

    def __init__(self, arg1, arg2, arg3):
        if isinstance(arg1, Rule) and isinstance(arg2, object) and isinstance(arg3, Assignment): # object: DialogueState
            rule, state, filled_slots = arg1, arg2, arg3
            """
            Anchors the rule in the dialogue state. The construction process leads to the determination of:
            <li>the relevance of the rule in the given dialogue state
            <li>the range of possible values for the input nodes
            <li>the set of parameters associated with the rule
            <li>the set of possible effects generated by the rule
            <li>the set of possible values for the output nodes
    
            :param rule: the probabilistic rule
            :param state: the dialogue state
            :param filled_slots: filled
            """
            self._rule = rule
            self._id = rule.get_rule_id()

            if not filled_slots.is_empty():
                self._id += "(" + str(filled_slots) + ")"

            self._effects = set()
            self._outputs = ValueRange()
            self._parameters = set()
            self._filled_slots = filled_slots
            self._relevant = False
            self._cache = None

            self._inputs = ValueRange()
            for template in rule.get_input_variables():
                if template.is_filled_by(filled_slots):
                    t2 = str(template.fill_slots(filled_slots))

                    if state.has_chance_node(t2):
                        self._inputs.add_values(t2, state.get_chance_node(t2).get_values())
                    # else:
                    #     raise ValueError('No such variable: %s' % t2)

            conditions = self._inputs.linearize()

            if rule.get_rule_type() == RuleType.PROB:
                self._cache = dict()

            self._variables = set(self._inputs.get_variables())

            for condition in conditions:
                condition.add_assignment(filled_slots)

                cached_output = self.get_cached_output(condition)
                self._relevant = self._relevant or (not cached_output.is_void())

                for output in cached_output.get_pairs():
                    effect = output[0]
                    param = output[1]
                    self._effects.add(effect)
                    self._outputs.add_assign(effect.get_assignment())
                    for v in param.get_variables():
                        if state.has_chance_node(v):
                            self._parameters.add(v)

            if self._relevant and rule.get_rule_type() == RuleType.UTIL:
                self._variables.update(self._outputs.get_variables())
                self._cache = dict()

        else:
            raise NotImplementedError()

    @dispatch(str, str)
    def modify_variable_id(self, old_id, new_id):
        """
        Does nothing.
        """
        if self._id == old_id:
            self._id = new_id

    @dispatch(float)
    def prune_values(self, threshold):
        """
        Does nothing.
        """
        return False

    # ===================================
    # GETTERS
    # ===================================

    @dispatch()
    def is_relevant(self):
        """
        Returns true if the anchored rule is relevant (that is, it at least one
        matching rule case is non-empty), and false otherwise.

        :return: true if rule is relevant, and false otherwise.
        """
        return self._relevant

    @dispatch()
    def get_input_range(self):
        """
        Returns the value range for the input variables

        :return: the input range
        """
        return self._inputs

    @dispatch()
    def get_input_variables(self):
        return self._inputs.get_variables()

    @dispatch()
    def get_outputs(self):
        """
        Returns the output variables for the rule

        :return: the output variables
        """
        return self._outputs.get_variables()

    @dispatch()
    def get_output_range(self):
        """
        Returns the value range for the output variables

        :return: the output range
        """
        return self._outputs

    @dispatch()
    def get_effects(self):
        """
        Returns the set of possible effects associated with the anchored rule

        :return: set of possible effects
        """
        return self._effects

    @dispatch()
    def get_rule(self):
        """
        Returns the rule

        :return: the rule
        """
        return self._rule

    @dispatch()
    def get_parameters(self):
        """
        Returns the set of parameter nodes for the anchored rule

        :return: the set of parameter nodes
        """
        return self._parameters

    @dispatch(Assignment, Value)
    def get_prob(self, condition, head):
        """
        Returns the probability for P(head|condition), where head is an assignment of
        an output value for the rule node.

        :param condition: the conditional assignment
        :param head: the head assignment
        :return: the probability
        """
        output_table = self.get_prob_distrib(condition)
        prob = output_table.get_prob(head)
        return prob

    @dispatch(Assignment)
    def get_util(self, full_input):
        """
        Returns the utility for Q(input), where input is the assignment of values for
        both the chance nodes and the action nodes

        :param full_input: the value assignment
        :return: the corresponding utility
        """
        total_util = 0.0
        output = self.get_cached_output(full_input)

        for effect_output in output.get_effects():
            effect_condition = effect_output.convert_to_condition()

            if effect_condition.is_satisfied_by(full_input):
                param = output.get_parameter(effect_output)
                total_util += param.get_value(full_input)

        return total_util

    @dispatch(Assignment)
    def get_posterior(self, condition):
        """
        Returns the probability table associated with the given input assignment

        :param condition: the conditional assignment
        :return: the associated probability table (as a CategoricalTable) distribution
                could not be calculated.
        """
        return MarginalDistribution(self, condition)

    @dispatch()
    def get_values(self):
        """
        Returns the possible values for the rule.
        """
        return self.get_effects()

    @dispatch(Assignment)
    def sample(self, condition):
        """
        Samples one possible output value given the input assignment

        :param condition: the input assignment
        :return: the sampled value
        """
        output_table = self.get_prob_distrib(condition)
        return output_table.sample()

    @dispatch()
    def get_variable(self):
        """
        Returns the label of the anchored rule

        :return: the label of the anchored rule
        """
        return self._id

    @dispatch(Assignment)
    def get_prob_distrib(self, assignment):
        output = self.get_cached_output(assignment)

        builder = CategoricalTableBuilder(self._id)
        for effect in output.get_effects():
            param = output.get_parameter(effect)
            param_value = param.get_value(assignment)
            if param_value > 0:
                builder.add_row(effect, param_value)

        if builder.is_empty():
            self.log.warning("probability table is empty (no effects) for input %s and rule %s" % (assignment, str(self)))
            # raise ValueError()

        return builder.build()

    # ===================================
    # UTILITY AND PRIVATE METHODS
    # ===================================

    def __copy__(self):
        """
        Returns a copy of the distribution

        :return: the copy
        """
        return self

    def __str__(self):
        """
        Returns the pretty print for the rule

        :return: the pretty print
        """
        return str(self._rule)

    @dispatch(Assignment)
    def get_cached_output(self, param):
        """
        Returns the output of the anchored rule (using the cache if the input
        assignment is a sample).

        :param param: the input assignment
        :return: the output of the rule
        """
        if self._cache is None:
            assignment = Assignment([param, self._filled_slots])
            return self._rule.get_output(assignment)
        elif param.size() > len(self._variables):
            param = param.get_trimmed(self._variables)

        assign = Assignment([param, self._filled_slots])
        if assign not in self._cache:
            self._cache[assign] = self._rule.get_output(assign)

        return self._cache[assign]
